{
  "creators-guide/introduction/features.html": {
    "href": "creators-guide/introduction/features.html",
    "title": "Features | VPE Documentation",
    "keywords": "Features This section documents what's already working. If it's not, then that's a bug, and you should let us know . Materials We convert Visual Pinball's materials to materials compatible with the active render pipeline. That means materials look similar to Visual Pinball by default, while there's still a lot of potential left to tweak materials using the full material configuration of Unity. Bord's \"Viking\" rendered in VPX (left) and imported as-is in VPE's built-in renderer (right). Meshes Visual Pinball dynamically generates meshes for most of the game items. VPE has ported that code and does the same when loading a table. A rubber mesh generated in the editor Physics We have nearly finished porting Visual Pinball's physics engine to VPE. That means the ball and flipper behavior should be identical to Visual Pinball. This includes physics-based movement from flippers, gates and spinners, as well as animated targets, triggers and plungers. Events The physics engine emits the same events as Visual Pinball. That means you can subscribe to collision events and other game item-specific events. For example, for subscribing to the flip event of a flipper, you would do: table.Flipper(\"LeftFlipper\").LimitEos += (sender, args) => { // do something! }; Note While it's not clear how we'll handle scripting, most events can probably be configured visually in the editor and don't need to be handled via scripting. Cross Platform Unity supports a lot of platforms . Our continuous integration builds for Windows (x86/x64), macOS (x64) and Linux (x64). Besides Windows, some of our developers work on macOS, and we regularly test on Linux as well. File Format We care about backwards-compatibility to Visual Pinball. VPE can read and write .vpx files and supports the full data set. This means that you can load a table into VPE, edit it, export it to .vpx and load it back into Visual Pinball. Note VPE will at some point need to save additional data that isn't available in Visual Pinball. However, the .vpx structure is like a virtual file system, so we can do that without breaking backwards-compatibility. Editor Extensions Unity allows full editor customization. So we're adding the managers, panels, and toolboxes from Visual Pinball into the Unity editor: What you're seeing here is the toolbox as well as a few manager windows we've ported: Material Manager Image Manager Layer Manager Inspector acting as VP's Options Panel You can dock these as you wish, or even undock them and move them to another monitor. Not in the above screenshot but also ported are: Collections Manager Sound Manager VPE is also able to edit drag points. Moving those (in 3D!) re-generates the mesh on the fly: Lastly, we can visualize the colliders of any object. This can be useful to debug, and also to check whether you may have objects set to collide which actually shouldn't (or vice versa)! Patching System There are common patterns for VPX tables that are obsolete in VPE. For instance, VPE doesn't need a flipper shadow mesh, because it can do dynamic lighting out of the box. For that reason, we have a simple but sophisticated patcher system that allows us to apply changes to a table when imported. Of course the changes don't apply to the table data itself but to how we convert it into the Unity scene. You can read more about it here . Missing Features There are some things you might expect to work, but don't, because they're not yet implemented. Here's an incomplete list of those things. Key Assignments Currently, we grab left and right shift and map it to LeftFlipper and RightFlipper respectively. If the flippers are named differently, it doesn't work. VPE will provide a simple mapping mechanism where authors can link semantic key events to table logic and users can link keyboard keys to those key events. Performance When building the table, performance is okay but still not satisfactory. We think we can still do better. Runtime Import Right now, when you \"build\" your game and run it, Unity will compile it into binary assets. We want to avoid authors distributing those binaries, because they hide how things are done prevent further modding by other creators. Both of these aspects are crucial in building an ecosystem, so the goal is to only compile the player itself and load the tables at runtime. Ball Destruction Currently balls can't be destroyed during gameplay, so every drain will just leave them on the table, resulting in poor performance. Planned Features This section will at some point contain a list of major new features."
  },
  "creators-guide/editor/switch-manager.html": {
    "href": "creators-guide/editor/switch-manager.html",
    "title": "Switch Manager | VPE Documentation",
    "keywords": "Switch Manager During gameplay, the gamelogic engine needs to know what is happening on the playfield. For that, real pinball tables have switches on the playfield that signal when a ball rolls over or settles in a certain position. These switches are also built into targets, bumpers, kickers, and other mechanisms (see Supported Game Mechanisms below). Wiring these switches up to the gamelogic engine with code can be a tedious process, so VPE provides a graphical interface where you can do it easily. If you've named them appropriately it can even guess which switch maps to which game item. You can open the switch manager under Visual Pinball -> Switch Manager . Setup Imagine every row as a wire connecting the physical switch to the gamelogic engine. The relation between the two is 0..n -> 0..n , meaning you can link multiple switches to one input or a single switch to multiple inputs. IDs The first column ID shows the names of each switch that the gamelogic engine is aware of. Note As we cannot be 100% sure that the gamelogic engine has accurate data about the switch names, you can also add switch IDs yourself, but those should be the exception. Description The Description column is optional. If you're setting up a re-creation, you would typically use this for the switch name from the game manual. It's purely for your own benefit, and you can keep this empty if you want. Source The Source column defines where the element in the following column originates. There are four options: Playfield lets you choose a game item from the playfield Input System lets you choose an input action from a pre-defined list, e.g. cabinet switches Constant sets the switch once at the beginning of the game to the given value. Device lets you choose a switch device containing the switch. Switch devices are mechanisms that include multiple switches, for example troughs . Element The Element column is where you choose which element triggers the switch. For Playfield sources, you can choose a game item that triggers switch events. Currently, VPE only emits switch events for items that would do so in real life, i.e. bumpers, flippers, gates, targets, kickers, spinners and triggers. Note We realize that you might want to use other game items like ramps and walls to emit switch events as well, and we will address this at some point, but for now we're keeping it simple. If Input System is selected, you choose which input action to use (it's an \"action\", because it's not an permanent key binding). Actions may have default key bindings, but the final bindings to a key or other input will be defined in the host application (the VPE player). If the source is a Device , then there are two values to select. The actual switch device, and which switch of that device should be connected to the gamelogic engine. Finally, if Constant is selected, you choose the value that will be permanently set at the beginning of the game. Pulse Delay Internally, VPE connects switches to events. For example, a trigger on the playfield has a Hit event, which occurs when the ball rolls into the trigger's collision zone, and an UnHit event when the ball leaves that zone. These two events close and open the trigger's switch. However, not all mechanisms behave like that. For example a spinner emits a single Spin event. So to prevent the switch from being closed indefinitely VPE automatically re-opens it after a given delay. We call that the Pulse Delay . \"Pulse\", because it gets triggered by one event and reopens after a brief delay. In most cases, you can leave the default delay of 250ms. What's important is that the gamelogic engine gets notified not too long after the switch was closed. Note that if pulse delay is set to 0, the switch will stay closed. Supported Game Mechanisms Below a list of game mechanisms that contain built-in switches. Closes Opens Bumper On ball collision After pulse delay Flipper On EOS, i.e. when the flipper reaches its end position When the flipper switch is opened, i.e. the flipper starts moving down again Gate When ball is passing through the gate When ball has passed through Target On collision After pulse delay Kicker When ball enters the kicker When ball's outside the kicker Spinner On each spin After pulse delay Trigger When the ball rolls over the trigger When the ball is outside of the trigger"
  },
  "creators-guide/editor/wire-manager.html": {
    "href": "creators-guide/editor/wire-manager.html",
    "title": "Wire Manager | VPE Documentation",
    "keywords": "Wire Manager Using the Switch Manager , you can wire playfield and cabinet switches to the Gamelogic Engine . Similarly, the Coil Manager and Lamp Manager let you connect playfield elements to the outputs of the Gamelogic Engine. The Wire Manager allows you to bypass the gamelogic engine and connect switches directly to coils and lamps. This can be useful for debugging, but also for game logic that might not be covered by the gamelogic engine. You can open the wire manager under Visual Pinball -> Wire Manager . Setup Every row in the wire manager's table corresponds to a connection between a switch and an element that takes an input. You can connect multiple switches to one element or a single switch to multiple elements. In the following, we call the switch the source and the element it is connected to the destination . Description The first column Description is optional. It can help better organize all the connections, but can be left empty if you want. Source The Source column defines the type of source you are connecting to. There are four types: Playfield lets you select any game item that qualifies as a source from the playfield. Input System lets you select an input action from a pre-defined list, e.g. cabinet switches. Constant sets the destination to a constant value. Device lets you select a source device. Such devices are mechanisms that include multiple sources, for example troughs . Source Element The Source Element column is where you select which element acts as the source. For Playfield sources, you can select a game item that triggers switch events. Currently, VPE emits switch events for items that would do so in real life, i.e. bumpers, flippers, gates, targets, kickers, spinners and triggers. If Input System is selected, you select which input action to use. Actions may have default key bindings, but the final bindings to a key or other input will be defined in the host application (the VPE player). If the source is a Device , then there are two values to select. The actual source device, and which switch of that device should be connected to the gamelogic engine. Finally, if Constant is selected, you select the value that will be permanently set at the beginning of the game. This might me useful for lamps that are always on. Destination Under Destination you can select the type of the element that will receive the switch changes. There are two types to choose from: Playfield lets you select any game item that qualifies as a destination from the playfield Device lets you choose a destination device. Such devices are mechanisms that include multiple coils or lamps, for example troughs . Destination Element The Destination Element column is where you select which specific element in the destination column should receive switch changes. If Device was selected in the previous column, both the actual device and the element within the device have to be selected. Pulse Delay Internally, VPE connects switches to events. Some switchable game items only emit the switch closed event. Such items are spinners and targets. These are elements where the re-opening of the switch does not have any semantic value. In order for those to not stay closed forever, VPE closes them after a given delay. We call this the Pulse Delay . This field is only visible if the input source is a pulse-driven source."
  },
  "creators-guide/manual/manual.html": {
    "href": "creators-guide/manual/manual.html",
    "title": "Manual | VPE Documentation",
    "keywords": "Manual This section will document the following: Game Items Pinball Mechanisms Scripting Physics Plugins"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome | VPE Documentation",
    "keywords": "Welcome to the documentation of the Start here with the creator's guide . Be aware we're at the very beginning of writing documentation. You'll see weird content."
  },
  "creators-guide/setup/updating-vpe.html": {
    "href": "creators-guide/setup/updating-vpe.html",
    "title": "Updating VPE | VPE Documentation",
    "keywords": "Updating VPE VPE is under heavy development, so it's frequently updated, usually multiple times per week. In order to not have to delete your existing VisualPinball.Engine folder and download and extract the code each time, we recommend using git. Git is a distributed version control system. It's very sophisticated but can also be a bit overwhelming to use. However, with the cheat sheet below you should be able to handle it. First you need to download git . Make sure it's in your PATH environment variable. There are free GUIs for git such as Fork , GitKraken or Source Tree , but we'll focus on the command line version on Windows here. Linux and macOS are similar but use a command shell or terminal window. Open a command prompt by pressing the Windows key and typing cmd , followed by enter. Make sure that git is installed by typing git --version . This should return something like git version 2.18.0.windows.1 . Next, go to the folder where you want to have VPE installed. If there is already a folder where you've extracted VPE from before, delete it. Following the recommended file structure, you would type: cd %userprofile%\\VPE git clone https://github.com/freezy/VisualPinball.Engine.git This downloads the latest version of VPE into %userprofile%\\VPE\\VisualPinball.Engine and keeps a link to GitHub. In the future, if you want to update VPE, it's simply a matter of going into the folder and \"pull\" the changes: cd %userprofile%\\VPE\\VisualPinball.Engine git pull However, you might have experimented in the VPE folder to test out stuff, and git complains it can't update. Here is a way to discard all local changes and pull in what's on GitHub: git fetch --prune git checkout -- ** git reset --hard origin/master Warning Should you have committed changes (as in, you've developed something, and added and commited it to git), this will also discard those changes. But if you have done that you're probably a seasoned developer and know what you're doing, right? :)"
  },
  "creators-guide/editor/multiple-tables.html": {
    "href": "creators-guide/editor/multiple-tables.html",
    "title": "Working with Multiple Tables | VPE Documentation",
    "keywords": "Working with Multiple Tables When working on a creation, you might want to load other tables to pick assets from. For that, Visual Pinball lets you open multiple tables allowing to switch and copy elements between them relatively quickly. With VPE, you can create or import multiple tables into your scene. VPE's manager panels will switch context when an element from a different table is selected in either the Scene view or the Hierarchy. Tip You can lock a manager window to the selected table by clicking on the small lock in the top right corner: Warning We don't have multi-table support during runtime yet. The idea is that in the future, you would be able to select which table is the runtime table. Warning Moving elements between multiple tables is not implemented yet, there is an open issue ."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "Scripting API | VPE Documentation",
    "keywords": "This section will contain the scripting API documentation."
  },
  "creators-guide/introduction/overview.html": {
    "href": "creators-guide/introduction/overview.html",
    "title": "Overview | VPE Documentation",
    "keywords": "Overview The Visual Pinball Engine (which we call \"VPE\") is an open source pinball simulator that you can use to create pinball games for Windows, macOS, and Linux. It's based on the famous Visual Pinball (often abbreviated \"VP\", or \"VPX\" for its latest version 10) meaning VPE's physics simulation matches that in VPX, and it can read and write the same file format. VPE uses Unity for its underlying game architecture. Unity is one of the leading cross-platform game engines and provides VPE with an advanced render pipeline that produces high-quality visuals and is continuously maintained and updated to work with new hardware features. Unity also comes with an amazing editor, which VPE extends to make the table creation process as easy as possible. An imported .vpx file in VPE, using Unitys' High Definition Render Pipeline. Note Technically, VPE is what we call a \"library\". A library is not executable per se, because it needs a host application. We will provide such a host application in the future, but for now you will need to create a new Unity project and add VPE as a package in order to run it. Audience This documentation is mainly aimed at table creators (\"authors\"). Since it covers table scripting as well, it also contains code-related documentation. VPE is currently not in a state where it is usable by the general public (\"players\"). Documentation about how to setup VPE to play will follow at a later stage."
  },
  "creators-guide/editor/unity-components.html": {
    "href": "creators-guide/editor/unity-components.html",
    "title": "Unity Components | VPE Documentation",
    "keywords": "Unity Components When loading or creating a table in Unity, what you're creating is a hierarchy of GameObjects , the basic building blocks of Unity scenes. By default we group game items by their type when importing, but you can arrange them however you want. To give the GameObjects behavior during gameplay, we add components onto them. VPE comes with large number of components that are used to set up and control the game mechanisms of the table, and advanced programmers can contibute new ones. Note During runtime, VPE converts the GameObjects and components into entities in Unity's DOTS workflow . There are special components used to control this conversion which we call Authoring Components . If you've never heard about GameObjects or components, we recommmend you read through the links in the first two paragraphs. They are short, to the point, and a much better introduction than we could provide here. Components vs Game Items In Visual Pinball , components are what you see in the options panel when you click on a game item. You'll typically find sections for adjusting physical behavior, visual display, and geometric shape of the game item you're editing. Internally, all of these sections belong to the same game item. In VPE , we have separate components for each of these sections. There are four different types of components: The Main Component represents the actual game item. A Collider Component adds physical behavior to the game item. It defines how the item interacts with other objects, for example what bounciness, friction and randomness is applied to a pinball hitting the item. Mesh Components generate meshes, i.e. the geometry used to render the object on the playfield. The results are the procedurally generated 3d objects rendered in the scene. Animation components apply movement to the game item. If the entire object is moving (for example a flipper), that is handled by the collision component, but for items where only parts move (e.g. the plate of a gate, or the ring of a bumper) these components apply the movement to the GameObject. Let's look at a flipper: Here, we see the main component ( Flipper ), the collider component ( Flipper Collider ), and two mesh components ( Flipper Base Mesh and Flipper Rubber Mesh ) inside VPE compared to Visual Pinball. While the main and collider component sit on the base GameObject, each mesh component is on its own child GameObject. This is how Unity works - a GameObject only contains one component of each type. Note Internally, VPE still keeps a single set of data. That's why you see the collapsed Base Mesh , Rubber Mesh and Physics sections in the main component. When you change values there, the corresponding values in the other components will update at the same time. In general, you don't have to manually manage all this. When creating game items via the toolbox, the new GameObject will already have all the necessary components, as will the items created when importing a .vpx file. This separation of logic has a few advantages. First, it's more obvious how a game item behaves. No collider component? That means the game item is not collidable. No mesh component? It's (permanently) invisible. But there are other advantages, as you will see in the next section. Combining Components VPE allows you to mix and match components onto game items. For example, for a given game item, you could assign a collider or mesh from another type. The most common use case is replacing built-in meshes with primitives, removing the original mesh component and replacing it with a generated version. But there are other usages, like using a primitive collider on a rubber. You can also add multiple children with colliders (or meshes) for a game item. We call this parenting . The game item that overrides a given behavior is still created, but serves as a parent container to other game items. The advantage compared to Visual Pinball, where you would create individual game items, is that VPE treats them as one single logical entity. For example, VPE will automatically rotate a primitive flipper item when it's parented under a flipper, and events from multiple colliders will be emitted from the same parent object. Supported Combinations Not every game item can be parented to any other game item. It doesn't make much sense to use a flipper collider for a bumper. In fact, most of the combinations are unsupported. Here's what VPE does support so far: Supported Meshes Supported Colliders Supported Animators Bumper Bumper Base, Bumper Cap, Bumper Ring, Bumper Skirt, Primitive Bumper Bumper Ring, Bumper Skirt Flipper Flipper Base, Flipper Rubber, Primitive Flipper Gate Gate Bracket, Gate Wire, Primitive Gate Gate Wire Hit Target Hit Target, Primitive Hit Target Hit Target, Drop Target Kicker Kicker, Primitive Kicker Light Light, Primitive Plunger Flat Plunger, Plunger Rod, Plunger Spring Plunger Plunger Primitive Primitive Primitive, Ramp, Wall Ramp Ramp, Primitive Ramp Rubber Rubber, Primitive Rubber, Surface, Primitive Spinner Spinner Bracket, Spinner Plate, Primitive Spinner Spinner Plate Surface Surface, Primitive Surface, Primitive Trigger Trigger, Primitive Trigger Trigger Naming Conventions In order to maintain backward compatibility with Visual Pinball, VPE relies on naming conventions to parent one game item to another. There are two suffixes that have special meaning for VPE: _Mesh applies the game item's mesh to its parent _Collider applies the game item's collider to its parent For example, if in Visual Pinball you name a primitive LeftFlipper_Mesh , VPE will look for a LeftFlipper game item and replace its mesh with the mesh of that primitive. In other words, it will parent LeftFlipper_Mesh to LeftFlipper and disable LeftFlipper 's original mesh. Another example: If in Visual Pinball you name a rubber LeftSlingshot and two primitives LeftSlingshot_Collider_Soft and LeftSlingshot_Collider_Hard , VPE will disable the collider of LeftSlingshot and use both the other colliders instead. During gameplay when the ball hits either LeftSlingshot_Collider_Soft or LeftSlingshot_Collider_Hard , the Hit event will be emitted on LeftSlingshot . Warning When you export to .vpx and you have parented items that don't follow the naming convention, the parenting will get lost when re-importing the table into VPE. In the future, VPE may offer to (or even automatically) rename the parented children on export, but that's still on our TODO list. Visibility In order to determine whether a game item is visible, VPE looks at the hierarchy and the mesh components of its GameObject. If a game item has no mesh component, its automatically set to invisible . It's also invisible if the GameObject is set to inactive (the checkbox at the top left in the Inspector)."
  },
  "creators-guide/manual/mechanisms/troughs.html": {
    "href": "creators-guide/manual/mechanisms/troughs.html",
    "title": "Troughs / Ball Drains | VPE Documentation",
    "keywords": "Troughs / Ball Drains If you are unfamiliar with ball troughs, have a quick look at MPF's documentation , which does an excellent job explaining them. VPE comes with a trough mechanism that simulates the behaviour of a real-world ball trough. This is especially important when emulating existing games, since the gamelogic engine expects the trough's switches to be in a plausible state, or else it may have errors. Creating a Trough When importing a .vpx file that doesn't have any troughs (which is likely, because Visual Pinball doesn't currently handle them in the same way as VPE), VPE will automatically add a main trough to the root of the table. If you're creating a trough for a new game, click on the Trough button in the toolbox. Linking to the Playfield To interact with the game, you'll need to setup an entry kicker to drain the ball into the trough, and an exit kicker to release a new ball from the trough. This terminology may seem weird, since the ball exits the playfield when draining, but from the the trough's perspective, that's where the ball enters . You can setup the kickers by selecting the trough in the hierarchy panel and linking them to the desired kickers using the inspector. Switch Setup The number of simulated switches in the trough depends on the Switch Count property in the inspector panel. For recreations, you can quickly determine the number of trough switches by looking at the switch matrix in the operation manual, it usually matches the number of balls installed in the game. Open the switch manager and add the trough switches if they're not already there. As Destination select \"Device\", under Element , select the trough you've created and which switch to connect. For a five-ball trough, it will look something like this: Coil Setup VPE's trough supports two coils, an entry coil which drains the ball from the outhole into the trough, and an eject coil which pushes a new ball into the plunger lane. Open the coil manager , find or add the coils, and link them to the trough like you did with the switches:"
  },
  "creators-guide/manual/gamelogic-engine.html": {
    "href": "creators-guide/manual/gamelogic-engine.html",
    "title": "Gamelogic Engine | VPE Documentation",
    "keywords": "Gamelogic Engine When playing a pinball game, some part of the table is driving the gameplay, i.e. deciding when to flip a coil, turn on a light, show something on the DMD, and so on. In VPE, we call this the Gamelogic Engine . The gamelogic engine is purely gameplay driven. It gets input from switches, computes what will happen next, and updates the hardware components of the table. It does not handle game mechanics, which are about simulating the hardware behavior of the table - it just toggles it. Classic examples of gamelogic engines are MPF and PinMAME . Note Let's take a spinning wheel on the playfield as an example. The game logic engine's job is to know when to turn it on and off. The game mechanics component of the spinning wheel is about rotating the actual playfield element with the right speed, acceleration, and handle ball collisions with a given friction. At the moment it's still unclear how VPE will deal with game mechanics. Initially, we will ship a bunch of game mechanics ready to use, and the future will tell how authors can create their own. In Visual Pinball, the gamelogic engine is part of the table script, which in most cases uses VPM to drive the game. So a part of the table script is about piping data into VPM and handling its outputs (lamp changes, coil changes, and so on). Since VPE defines a clear API (like a contract) between the table and the gamelogic engine, we will provide tools to make this easy for you. Currently there is a Switch Manager which manages switches. Soon there will be additional managers for lamps and coils, where you can connect your playfield elements to the gamelogic engine using a UI. Ultimately, that means if your table uses an existing gamelogic engine like MPF or PinMAME, and the table doesn't contain any exotic game mechanics, that's all you need to do. You can set up your table without a single line of code!"
  },
  "creators-guide/setup/running-vpe.html": {
    "href": "creators-guide/setup/running-vpe.html",
    "title": "Running VPE | VPE Documentation",
    "keywords": "Running VPE Now we can get begin with some simple game play. Open Visual Pinball, create a new \"blank\" table, and save it somewhere. In Unity, go to Visual Pinball -> Import VPX and choose the new .vpx file. You should now see Visual Pinball's blank table in the Editor's scene view: Now, we don't see much of our table. That's because the scene view's camera doesn't really point on it. Using the right mouse button and the A W S D keys while keeping right mouse button pressed, fly somewhere you have a better view of the table. Tip Check Unity's documentation on Scene view navigation for a more complete list of ways to move the camera around the scene. Now that you have the camera of the scene view somewhat aligned. Tip A pinball table is a relatively small object, so Unity's \"gizmo\" icons marking scene objects are huge. You can make them smaller with the Gizmos menu by using the 3D Icons slider. The view in the scene tab is not the camera used in game. The Scene View really allows you to fly anywhere, zoom in on things you're working on, switch from orthagonal view to perspective, and so on. It's where you get work done. During game play, another camera is used. It's the one already in your scene hierarchy (called Main Camera ), and you can look through it by switching to the Game View window. This camera can be moved using Unity's gizmos , by selecting it in the hierarchy and moving and tilting it around. Tip A quick way to fix the game camera is to align it with the scene view camera. To do that, select the camera in the hierarchy, then click on the GameObject menu and select Align with view . Now, click on the play button. This will run your scene. Test that the shift keys move the flippers. Press B to add a new ball. If it's not already choppy, it will get after a dozen or so balls, because VPE currently doesn't destroy them. The choppiness is also due to running the game inside the editor, fetching data during gameplay, and the code not being optimized. This should all go away if you choose Build and Run under the File menu. Running it as \"build\" should give you significantly smoother gameplay. Tip If you want to enter play mode more quickly, you can check the experimental play mode option described here ."
  },
  "creators-guide/setup/installing-vpe.html": {
    "href": "creators-guide/setup/installing-vpe.html",
    "title": "Installing VPE | VPE Documentation",
    "keywords": "Installing VPE Unity In order to start creating or tweaking tables with VPE, the first thing you'll need to install is Unity . You will need a developer account, which is free. Note As long as you don't use VPE for a game that makes $100K or more in revenue or funding a year, the free Personal plan is sufficient for you. Unity uses an application called Unity Hub to update itself and provide quick access to your projects. The install process is straight-forward and documented here if you run into troubles. When installing Unity, use the latest 2020.1 version. You can leave all the other options unchecked. Once Unity is downloaded and installed, you'll need to create a new project. Unity has multiple render pipelines, and you'll be asked which render pipeline to use in your project: You'll have the choice between: 2D - For 2D games. VPE doesn't support this renderer. 3D - Unity's original built-in renderer. High Definition RP - Unity's new HDRP , used for high-end platforms. Universal Render Pipeline - Unity's URP is aimed at mobile and low-end platforms. We recommend using HDRP. It's not as mature as the built-in renderer, but it's able to achieve better visuals, and it's what Unity will be focusing on in the future. Note If you're just creating a throw-away project for testing out gameplay, the built-in renderer is more tested and faster to set up. We also support the URP, but it's not as well tested as the other two pipelines. Next, enter a project name and a location for your project. We recommend putting the render pipeline into the name, because in the future you might test out other pipelines and thus need to create additional projects. Tip We recommend creating a VPE folder in your user directory (which is called %userprofile% ), to contain all the VPE-related files. In this example that would be %userprofile%\\VPE\\Test Table - HDRP , which usually resolves to C:\\Users\\{username}\\VPE\\Test Table - HDRP . You're of course free to set this up however you want, but that's what we'll be referring to in the rest of the documentation. Clicking Create launches the Unity editor, pulls in all the dependencies for the new project, and compiles them. This can take a minute or two. HDRP Setup If you create an HDRP project, Unity provides you with a sample scene: It's best to start by removing the unneeded objects. In the hierarchy, select: and press delete . Similarly, to clean up the project, get rid of the extra assets in the project view: VPE Source Code Now you have your project and scene set up, let's bring VPE into the project. Go to the GitHub page and download the source code . You can do that by clicking on the green Code button, and choosing Downlaod ZIP . As mentioned above, we recommend extracting this into the %userprofile%\\VPE\\VisualPinball.Engine folder: In Unity, go to Window -> Package Manager . Click on the \"plus\" icon on the top left corner of the window, and choose Add package from disk . Choose package.json in the root folder of the extracted VPE source code. This will take a moment as Unity downloads and compiles all of VPE's dependencies. If during this time, you see the following warning: Click Yes . When complete, you should now have a Visual Pinball menu in the editor."
  },
  "creators-guide/editor/coil-manager.html": {
    "href": "creators-guide/editor/coil-manager.html",
    "title": "Coil Manager | VPE Documentation",
    "keywords": "Coil Manager On a real pinball table most moving parts, including the flippers, are triggered by coils (also called solenoids ). In VPE it's the job of the gamelogic engine to trigger them when needed. Just as the coils are physically wired to the power driver board on a regular machine they can be virtually connected in VPE using the coil manager under Visual Pinball -> Coil Manager . Setup Every row in the coil manager corresponds to a logical wire going from a gamelogic engine output to the coil. As with switches, a single coil can be linked to multiple outputs, and an output can be linked to multiple coils. IDs The first column, ID shows the name that the gamelogic engine exports for each coil. Note As we cannot be 100% sure that the gamelogic engine has accurate data about the coil names, you can also add coil IDs manually, but that should be the exception. Description The Description column is optional. If you're setting up a re-creation, you would typically use this for the coil name from the game manual. It's purely for your own benefit, and you can keep this empty if you want. Destination The Destination column defines where the element in the following column is located. There are two options: Playfield lets you select a game element on the playfield that features the coil Device lets you choose a coil device , a mechanism which may include multiple coils, such as a trough . Element The Element column is where you choose which specifc element in the destination column should be activated. VPE can receive coil events for bumpers, flippers, kickers and plungers and coil devices. Note Bumpers are currently hard-wired, i.e. their switch will directly trigger the coil without going through the gamelogic engine. That means they don't need to be configured in the switch or coil manager. VPE will make this configurable in the future. Type In the Type column you can define whether the coil is single-wound or dual-wound. There's an excellent page about the differences in MPF's documentation . In short, dual-wound coils have two circuits, one for powering the coil, and one for holding it, while single-wound coils only have one. This changes how the coil powers off: For single-wound coils, VPE uses the same coil's events for powering on and off. For dual-wound coils, it uses the on event from the main coil and the off event from the hold coil. Hold Coil When the coil type is set to Dual-Wound , this column defines the hold coil event, i.e. the event on which the coil powers off. Dual-wound coils are fairly common. For example, Medieval Madness has the following dual-wound coils: From the Medieval Madness manual In VPE, the two flippers would map to the following configuration:"
  },
  "creators-guide/manual/mechanisms/flippers.html": {
    "href": "creators-guide/manual/mechanisms/flippers.html",
    "title": "Flipper | VPE Documentation",
    "keywords": "Flipper Flippers. They flip. You can program them too !"
  },
  "creators-guide/vpe.html": {
    "href": "creators-guide/vpe.html",
    "title": "Features | VPE Documentation",
    "keywords": "Features Tutorial VPE Manual Game Items Pinball Mechanisms Scripting Physics Plugins About VPE About this Documentation Authors License and Copyright FAQ Glossary Contributing to VPE"
  },
  "api/VisualPinball.Unity.FlipperApi.html": {
    "href": "api/VisualPinball.Unity.FlipperApi.html",
    "title": "Class FlipperApi | VPE Documentation",
    "keywords": "Class FlipperApi The scripting API of the flipper. Inheritance System.Object VisualPinball.Unity.ItemApi < VisualPinball.Engine.VPT.Flipper.Flipper , VisualPinball.Engine.VPT.Flipper.FlipperData > FlipperApi Namespace : VisualPinball.Unity Assembly : VisualPinball.Unity.dll Syntax public class FlipperApi : ItemApi<Flipper, FlipperData>, IApi, IApiInitializable, IApiHittable, IApiRotatable, IApiCollidable, IApiSwitch, IApiCoil, IApiWireDest Methods | Improve this Doc View Source RotateToEnd() Enables the flipper's solenoid, making the flipper to start moving to its end position. Declaration public void RotateToEnd() | Improve this Doc View Source RotateToStart() Disables the flipper's solenoid, making the flipper rotate back to its resting position. Declaration public void RotateToStart() Events | Improve this Doc View Source Collide Event emitted when the flipper collided with the ball. Declaration public event EventHandler<CollideEventArgs> Collide Event Type Type Description EventHandler < VisualPinball.Unity.CollideEventArgs > | Improve this Doc View Source Hit Event emitted when the flipper was touched by the ball, but did not collide. Declaration public event EventHandler Hit Event Type Type Description EventHandler | Improve this Doc View Source Init Event emitted when the table is started. Declaration public event EventHandler Init Event Type Type Description EventHandler | Improve this Doc View Source LimitBos Event emitted when the flipper comes to rest, i.e. moves back to the resting position. Declaration public event EventHandler<RotationEventArgs> LimitBos Event Type Type Description EventHandler < VisualPinball.Unity.RotationEventArgs > | Improve this Doc View Source LimitEos Event emitted when the flipper reaches its end position. Declaration public event EventHandler<RotationEventArgs> LimitEos Event Type Type Description EventHandler < VisualPinball.Unity.RotationEventArgs > | Improve this Doc View Source Timer Declaration public event EventHandler Timer Event Type Type Description EventHandler"
  },
  "api/VisualPinball.Unity.html": {
    "href": "api/VisualPinball.Unity.html",
    "title": "Namespace VisualPinball.Unity | VPE Documentation",
    "keywords": "Namespace VisualPinball.Unity Classes FlipperApi The scripting API of the flipper."
  }
}